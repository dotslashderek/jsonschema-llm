package {{ package_name }};

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jsonschema.llm.engine.LlmRoundtripEngine;
import com.jsonschema.llm.engine.LlmTransport;
import com.jsonschema.llm.engine.LlmTransportException;
import com.jsonschema.llm.engine.ProviderConfig;
import com.jsonschema.llm.engine.ProviderFormatter;
import com.jsonschema.llm.engine.RoundtripResult;

import java.io.IOException;
import java.io.InputStream;

/**
 * Schema wrapper for the "{{ component_name }}" component.
 *
 * <p>Provides access to the pre-converted LLM-compatible schema and codec
 * for the {{ component_name }} component.
 */
public class {{ class_name }} {

    private static final ObjectMapper MAPPER = new ObjectMapper();

    private {{ class_name }}() {}

    /**
     * Load the LLM-compatible schema for {{ component_name }}.
     *
     * @return parsed JSON schema node
     * @throws IOException if the schema resource cannot be read
     */
    public static JsonNode schema() throws IOException {
        return loadResource("schemas/{{ schema_path }}");
    }

    /**
     * Load the codec (rehydration map) for {{ component_name }}.
     *
     * @return parsed codec JSON node
     * @throws IOException if the codec resource cannot be read
     */
    public static JsonNode codec() throws IOException {
        return loadResource("schemas/{{ codec_path }}");
    }

    /**
     * Load the original (pre-conversion) sub-schema for {{ component_name }}.
     *
     * <p>Use this as the validation/rehydration schema when calling
     * {@code LlmRoundtripEngine.generateWithPreconverted()}.
     *
     * @return parsed original JSON schema node
     * @throws IOException if the schema resource cannot be read
     */
    public static JsonNode original() throws IOException {
        return loadResource("schemas/{{ original_path }}");
    }

    /**
     * Run a full LLM roundtrip for {{ component_name }} using pre-built schema artifacts.
     *
     * <p>Convenience wrapper around {@link LlmRoundtripEngine#generateWithPreconverted}
     * that wires in the pre-built {@link #original()}, {@link #codec()}, and {@link #schema()}
     * so callers don't need to manage the three-way split themselves.
     *
     * @param prompt     the natural language prompt for the LLM
     * @param engine     an initialized {@link LlmRoundtripEngine}
     * @param formatter  provider-specific request formatter
     * @param config     provider endpoint/model configuration
     * @param transport  consumer-provided HTTP transport
     * @return the roundtrip result with rehydrated data and validation info
     * @throws IOException           if any schema resource cannot be read
     * @throws LlmTransportException if the transport fails
     */
    public static RoundtripResult generate(
            String prompt,
            LlmRoundtripEngine engine,
            ProviderFormatter formatter,
            ProviderConfig config,
            LlmTransport transport) throws IOException, LlmTransportException {
        return engine.generateWithPreconverted(
                original().toString(),
                codec().toString(),
                schema(),
                prompt,
                formatter,
                config,
                transport);
    }

    private static JsonNode loadResource(String path) throws IOException {
        try (InputStream is = {{ class_name }}.class.getClassLoader().getResourceAsStream(path)) {
            if (is == null) {
                throw new IOException("Resource not found: " + path);
            }
            return MAPPER.readTree(is);
        }
    }
}
