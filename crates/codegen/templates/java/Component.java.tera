package {{ package_name }};

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jsonschema.llm.engine.LlmRoundtripEngine;
import com.jsonschema.llm.engine.LlmTransportException;
import com.jsonschema.llm.engine.RoundtripResult;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

/**
 * Schema wrapper for the "{{ component_name }}" component.
 *
 * <p>Provides access to the pre-converted LLM-compatible schema and codec
 * for the {{ component_name }} component.
 */
public class {{ class_name }} {

    private static final ObjectMapper MAPPER = new ObjectMapper();
    private static final com.fasterxml.jackson.databind.ObjectWriter PATCH_WRITER =
            MAPPER.writerFor(new com.fasterxml.jackson.core.type.TypeReference<java.util.List<JsonPatchOp>>() {});

    private {{ class_name }}() {}

    // -----------------------------------------------------------------------
    // Schema accessors
    // -----------------------------------------------------------------------

    /**
     * Load the LLM-compatible schema for {{ component_name }}.
     *
     * @return parsed JSON schema node
     * @throws IOException if the schema resource cannot be read
     */
    public static JsonNode schema() throws IOException {
        return loadResource("schemas/{{ schema_path }}");
    }

    /**
     * Load the codec (rehydration map) for {{ component_name }}.
     *
     * @return parsed codec JSON node
     * @throws IOException if the codec resource cannot be read
     */
    public static JsonNode codec() throws IOException {
        return loadResource("schemas/{{ codec_path }}");
    }

    /**
     * Load the original (pre-conversion) sub-schema for {{ component_name }}.
     *
     * <p>Use this as the validation/rehydration schema when calling
     * {@code LlmRoundtripEngine.generateWithPreconverted()}.
     *
     * @return parsed original JSON schema node
     * @throws IOException if the schema resource cannot be read
     */
    public static JsonNode original() throws IOException {
        return loadResource("schemas/{{ original_path }}");
    }

    // -----------------------------------------------------------------------
    // Generate methods
    // -----------------------------------------------------------------------

    /**
     * Run a full LLM roundtrip for {{ component_name }} using pre-built schema artifacts.
     *
     * <p>Convenience wrapper around {@link LlmRoundtripEngine#generateWithPreconverted}
     * that wires in the pre-built {@link #original()}, {@link #codec()}, and {@link #schema()}
     * so callers don't need to manage the three-way split themselves.
     *
     * @param prompt the natural language prompt for the LLM
     * @param engine an initialized {@link LlmRoundtripEngine} (already configured with
     *               formatter, config, and transport)
     * @return the roundtrip result with rehydrated data and validation info
     * @throws IOException           if any schema resource cannot be read
     * @throws LlmTransportException if the transport fails
     */
    public static RoundtripResult generate(
            String prompt,
            LlmRoundtripEngine engine) throws IOException, LlmTransportException {
        return engine.generateWithPreconverted(
                original().toString(),
                codec().toString(),
                schema(),
                prompt);
    }

    /**
     * Run a full LLM roundtrip for {{ component_name }} with RFC 6902 JSON Patch
     * operations applied to the source schema before conversion.
     *
     * <p>Applies the patch to the original schema via the WASM engine, then converts
     * at runtime â€” producing a fresh schema/codec pair for the patched structure.
     *
     * <p>Use this to enrich, constrain, or restructure opaque fields (e.g., replacing
     * {@code {"type": "object"}} with a typed structure) without modifying the upstream schema.
     *
     * @param prompt the natural language prompt for the LLM
     * @param engine an initialized {@link LlmRoundtripEngine}
     * @param ops    RFC 6902 JSON Patch operations to apply to the source schema
     * @return the roundtrip result with rehydrated data and validation info
     * @throws IOException           if any schema resource cannot be read
     * @throws LlmTransportException if the transport fails
     */
    public static RoundtripResult generate(
            String prompt,
            LlmRoundtripEngine engine,
            List<JsonPatchOp> ops) throws IOException, LlmTransportException {
        String patchJson = PATCH_WRITER.writeValueAsString(ops);
        return engine.generateWithPatch(original().toString(), prompt, patchJson);
    }

    // -----------------------------------------------------------------------
    // Internal
    // -----------------------------------------------------------------------

    private static JsonNode loadResource(String path) throws IOException {
        try (InputStream is = {{ class_name }}.class.getClassLoader().getResourceAsStream(path)) {
            if (is == null) {
                throw new IOException("Resource not found: " + path);
            }
            return MAPPER.readTree(is);
        }
    }
}
