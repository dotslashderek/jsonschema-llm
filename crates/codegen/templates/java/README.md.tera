# {{ package_name }} SDK

Generated by [json-schema-llm](https://github.com/dotslashderek/json-schema-llm) `gen-sdk`.

## Components

| Component | Enum | Class |
|---|---|---|
{% for component in components -%}
| `{{ component.component_name }}` | `Component.{{ component.enum_name }}` | `{{ component.class_name }}` |
{% endfor %}

## Usage

### Unified generation (recommended for generic operations)

Use the `Component` enum and `SchemaGenerator` for dynamic dispatch â€” ideal when the target component is determined at runtime (e.g. from user input, config, or HTTP requests).

```java
import {{ package_name }}.SchemaGenerator;
import {{ package_name }}.SchemaGenerator.Component;
import com.jsonschema.llm.engine.*;

var engine = LlmRoundtripEngine.create(
    new OpenAIFormatter(),
    new ProviderConfig(
        "https://api.openai.com/v1/chat/completions",
        "gpt-4o",
        Map.of("Authorization", "Bearer " + apiKey)
    ),
    new HttpTransport()
);

// Generate any component by enum
RoundtripResult result = SchemaGenerator.generate(
    Component.{{ components.0.enum_name }},
    "Your prompt here",
    engine
);
System.out.println(result.data());

// Dynamic lookup from a string
Component component = Component.from("{{ components.0.component_name }}");
RoundtripResult result2 = SchemaGenerator.generate(component, "Your prompt here", engine);

engine.close();
```

### Focused component access

Import a specific component class directly when you know exactly which component you need at compile time.

```java
import {{ package_name }}.{{ components.0.class_name }};
import com.jsonschema.llm.engine.*;

// Direct generation
RoundtripResult result = {{ components.0.class_name }}.generate("Your prompt here", engine);

// Access individual artifacts
var schema   = {{ components.0.class_name }}.schema();
var codec    = {{ components.0.class_name }}.codec();
var original = {{ components.0.class_name }}.original();
```

## Build

```bash
mvn compile
```
