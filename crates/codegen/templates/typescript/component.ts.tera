/**
 * {{ component_name }} â€” generated component accessor.
 *
 * Provides pre-loaded LLM schema and codec for this component.
 * Use with @json-schema-llm/engine for full roundtrip orchestration.
 *
 * **Important**: This module resolves schema files relative to `dist/`.
 * Run `npm run build` before importing.
 */

import { readFileSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import type {
  LlmRoundtripEngine,
  LlmTransport,
  ProviderConfig,
  ProviderFormatter,
  RoundtripResult,
} from "@json-schema-llm/engine";

const __dirname = dirname(fileURLToPath(import.meta.url));

let _schemaCache: Record<string, unknown> | null = null;
let _codecCache: Record<string, unknown> | null = null;
let _originalCache: Record<string, unknown> | null = null;

/** Load the LLM-compatible schema for {{ component_name }}. */
export function schema(): Record<string, unknown> {
  if (_schemaCache === null) {
    const raw = readFileSync(join(__dirname, "..", "schemas", "{{ schema_path }}"), "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") {
      throw new Error(`Invalid schema JSON in {{ schema_path }}`);
    }
    _schemaCache = parsed as Record<string, unknown>; // We have to assert here but we validated it
  }
  return _schemaCache;
}

/** Load the codec (rehydration map) for {{ component_name }}. */
export function codec(): Record<string, unknown> {
  if (_codecCache === null) {
    const raw = readFileSync(join(__dirname, "..", "schemas", "{{ codec_path }}"), "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") {
      throw new Error(`Invalid codec JSON in {{ codec_path }}`);
    }
    _codecCache = parsed as Record<string, unknown>;
  }
  return _codecCache;
}

/** Load the original (pre-conversion) sub-schema for {{ component_name }}. */
export function original(): Record<string, unknown> {
  if (_originalCache === null) {
    const raw = readFileSync(join(__dirname, "..", "schemas", "{{ original_path }}"), "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") {
      throw new Error(`Invalid original schema JSON in {{ original_path }}`);
    }
    _originalCache = parsed as Record<string, unknown>;
  }
  return _originalCache;
}

/**
 * Run a full LLM roundtrip for {{ component_name }} using pre-built schema artifacts.
 *
 * Convenience wrapper that wires the pre-built {@link original}, {@link codec},
 * and {@link schema} into {@link LlmRoundtripEngine.generateWithPreconverted}
 * so callers don't need to manage the three-way split themselves.
 *
 * @param prompt - The natural language prompt for the LLM.
 * @param options.engine - An initialized {@link LlmRoundtripEngine}.
 * @param options.formatter - Provider-specific request formatter.
 * @param options.config - Provider endpoint/model configuration.
 * @param options.transport - Consumer-provided HTTP transport.
 * @returns RoundtripResult with rehydrated data and validation info.
 */
export async function generate(
  prompt: string,
  {
    engine,
    formatter,
    config,
    transport,
  }: {
    engine: LlmRoundtripEngine;
    formatter: ProviderFormatter;
    config: ProviderConfig;
    transport: LlmTransport;
  },
): Promise<RoundtripResult> {
  return engine.generateWithPreconverted(
    JSON.stringify(original()),
    JSON.stringify(codec()),
    schema(),
    prompt,
    formatter,
    config,
    transport,
  );
}
