/**
 * {{ component_name }} — generated component accessor.
 *
 * Provides pre-loaded LLM schema and codec for this component.
 * Use with @json-schema-llm/engine for full roundtrip orchestration.
 *
 * **Important**: This module resolves schema files relative to `dist/`.
 * Run `npm run build` before importing.
 */

import { readFileSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import type {
  LlmRoundtripEngine,
  RoundtripResult,
} from "@json-schema-llm/engine";

const __dirname = dirname(fileURLToPath(import.meta.url));

// -----------------------------------------------------------------------
// RFC 6902 JSON Patch types — zero third-party dependencies
// -----------------------------------------------------------------------

/** Add operation: insert or replace a value at the target path. */
export interface AddOp {
  readonly op: "add";
  readonly path: string;
  readonly value: unknown;
}

/** Remove operation: delete the value at the target path. */
export interface RemoveOp {
  readonly op: "remove";
  readonly path: string;
}

/** Replace operation: replace the value at the target path. */
export interface ReplaceOp {
  readonly op: "replace";
  readonly path: string;
  readonly value: unknown;
}

/** Move operation: move a value from one path to another. */
export interface MoveOp {
  readonly op: "move";
  readonly path: string;
  readonly from: string;
}

/** Copy operation: copy a value from one path to another. */
export interface CopyOp {
  readonly op: "copy";
  readonly path: string;
  readonly from: string;
}

/** Test operation: verify a value at the target path matches. */
export interface TestOp {
  readonly op: "test";
  readonly path: string;
  readonly value: unknown;
}

/** An RFC 6902 JSON Patch operation. */
export type JsonPatchOp = AddOp | RemoveOp | ReplaceOp | MoveOp | CopyOp | TestOp;

// -----------------------------------------------------------------------
// Schema accessors
// -----------------------------------------------------------------------

let _schemaCache: Record<string, unknown> | null = null;
let _codecCache: Record<string, unknown> | null = null;
let _originalCache: Record<string, unknown> | null = null;

/** Load the LLM-compatible schema for {{ component_name }}. */
export function schema(): Record<string, unknown> {
  if (_schemaCache === null) {
    const raw = readFileSync(join(__dirname, "..", "schemas", "{{ schema_path }}"), "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") {
      throw new Error(`Invalid schema JSON in {{ schema_path }}`);
    }
    _schemaCache = parsed as Record<string, unknown>; // We have to assert here but we validated it
  }
  return _schemaCache;
}

/** Load the codec (rehydration map) for {{ component_name }}. */
export function codec(): Record<string, unknown> {
  if (_codecCache === null) {
    const raw = readFileSync(join(__dirname, "..", "schemas", "{{ codec_path }}"), "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") {
      throw new Error(`Invalid codec JSON in {{ codec_path }}`);
    }
    _codecCache = parsed as Record<string, unknown>;
  }
  return _codecCache;
}

/** Load the original (pre-conversion) sub-schema for {{ component_name }}. */
export function original(): Record<string, unknown> {
  if (_originalCache === null) {
    const raw = readFileSync(join(__dirname, "..", "schemas", "{{ original_path }}"), "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") {
      throw new Error(`Invalid original schema JSON in {{ original_path }}`);
    }
    _originalCache = parsed as Record<string, unknown>;
  }
  return _originalCache;
}

// -----------------------------------------------------------------------
// Generate methods
// -----------------------------------------------------------------------

/**
 * Run a full LLM roundtrip for {{ component_name }} using pre-built schema artifacts.
 *
 * Convenience wrapper that wires the pre-built {@link original}, {@link codec},
 * and {@link schema} into {@link LlmRoundtripEngine.generateWithPreconverted}
 * so callers don't need to manage the three-way split themselves.
 *
 * @param prompt - The natural language prompt for the LLM.
 * @param engine - An initialized {@link LlmRoundtripEngine} already configured
 *                 with formatter, config, and transport.
 * @returns RoundtripResult with rehydrated data and validation info.
 */
export async function generate(
  prompt: string,
  engine: LlmRoundtripEngine,
): Promise<RoundtripResult> {
  return engine.generateWithPreconverted(
    JSON.stringify(original()),
    JSON.stringify(codec()),
    schema(),
    prompt,
  );
}

/**
 * Run a full LLM roundtrip for {{ component_name }} with RFC 6902 JSON Patch
 * operations applied to the source schema before conversion.
 *
 * Applies the patch to the original schema via the WASM engine, then converts
 * at runtime — producing a fresh schema/codec pair for the patched structure.
 *
 * Use this to enrich, constrain, or restructure opaque fields (e.g., replacing
 * `{"type": "object"}` with a typed structure) without modifying the upstream schema.
 *
 * @param prompt - The natural language prompt for the LLM.
 * @param engine - An initialized {@link LlmRoundtripEngine} already configured
 *                 with formatter, config, and transport.
 * @param ops - RFC 6902 JSON Patch operations to apply to the source schema.
 * @returns RoundtripResult with rehydrated data and validation info.
 */
export async function generateWithPatch(
  prompt: string,
  engine: LlmRoundtripEngine,
  ops: JsonPatchOp[],
): Promise<RoundtripResult> {
  const patchJson = JSON.stringify(ops);
  return engine.generateWithPatch(JSON.stringify(original()), prompt, patchJson);
}
