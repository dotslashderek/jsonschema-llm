/**
 * {{ component_name }} â€” generated component accessor.
 *
 * Provides pre-loaded LLM schema and codec for this component.
 * Use with @json-schema-llm/engine for full roundtrip orchestration.
 *
 * **Important**: This module resolves schema files relative to `dist/`.
 * Run `npm run build` before importing.
 */

import { readFileSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import type {
  LlmRoundtripEngine,
  RoundtripResult,
} from "@json-schema-llm/engine";
import type { JsonPatchOp } from "./jsonPatch.js";

export type { JsonPatchOp } from "./jsonPatch.js";

const __dirname = dirname(fileURLToPath(import.meta.url));

// -----------------------------------------------------------------------
// Schema accessors
// -----------------------------------------------------------------------

let _schemaCache: Record<string, unknown> | null = null;
let _codecCache: Record<string, unknown> | null = null;
let _originalCache: Record<string, unknown> | null = null;

/** Load the LLM-compatible schema for {{ component_name }}. */
export function schema(): Record<string, unknown> {
  if (_schemaCache === null) {
    const raw = readFileSync(join(__dirname, "..", "schemas", "{{ schema_path }}"), "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") {
      throw new Error(`Invalid schema JSON in {{ schema_path }}`);
    }
    _schemaCache = parsed as Record<string, unknown>;
  }
  return _schemaCache;
}

/** Load the codec (rehydration map) for {{ component_name }}. */
export function codec(): Record<string, unknown> {
  if (_codecCache === null) {
    const raw = readFileSync(join(__dirname, "..", "schemas", "{{ codec_path }}"), "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") {
      throw new Error(`Invalid codec JSON in {{ codec_path }}`);
    }
    _codecCache = parsed as Record<string, unknown>;
  }
  return _codecCache;
}

/** Load the original (pre-conversion) sub-schema for {{ component_name }}. */
export function original(): Record<string, unknown> {
  if (_originalCache === null) {
    const raw = readFileSync(join(__dirname, "..", "schemas", "{{ original_path }}"), "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") {
      throw new Error(`Invalid original schema JSON in {{ original_path }}`);
    }
    _originalCache = parsed as Record<string, unknown>;
  }
  return _originalCache;
}

// -----------------------------------------------------------------------
// Generate methods
// -----------------------------------------------------------------------

/**
 * Run a full LLM roundtrip for {{ component_name }} using pre-built schema artifacts.
 *
 * @param prompt - The natural language prompt for the LLM.
 * @param engine - An initialized LlmRoundtripEngine.
 * @returns RoundtripResult with rehydrated data and validation info.
 */
export async function generate(
  prompt: string,
  engine: LlmRoundtripEngine,
): Promise<RoundtripResult> {
  return engine.generateWithPreconverted(
    JSON.stringify(original()),
    JSON.stringify(codec()),
    schema(),
    prompt,
  );
}

/**
 * Run a full LLM roundtrip with RFC 6902 JSON Patch applied before conversion.
 *
 * @param prompt - The natural language prompt for the LLM.
 * @param engine - An initialized LlmRoundtripEngine.
 * @param ops - RFC 6902 JSON Patch operations to apply to the source schema.
 * @returns RoundtripResult with rehydrated data and validation info.
 */
export async function generateWithPatch(
  prompt: string,
  engine: LlmRoundtripEngine,
  ops: JsonPatchOp[],
): Promise<RoundtripResult> {
  const patchJson = JSON.stringify(ops);
  return engine.generateWithPatch(JSON.stringify(original()), prompt, patchJson);
}
