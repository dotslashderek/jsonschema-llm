//! # jsonschema-llm-core
//!
//! Convert any JSON Schema (Draft 2020-12) into an LLM-compatible
//! structured output schema with full round-trip rehydration support.
//!
//! ## Quick Start
//!
//! ```rust,no_run
//! use jsonschema_llm_core::{convert, ConvertOptions, Target};
//!
//! let schema = serde_json::json!({
//!     "type": "object",
//!     "properties": {
//!         "name": { "type": "string" },
//!         "age": { "type": "integer", "minimum": 0 }
//!     },
//!     "required": ["name"]
//! });
//!
//! let result = convert(&schema, &ConvertOptions::default()).unwrap();
//! println!("Converted: {}", serde_json::to_string_pretty(&result.schema).unwrap());
//! println!("Codec: {}", serde_json::to_string_pretty(&result.codec).unwrap());
//! ```

pub mod codec;
pub mod codec_warning;
pub mod config;
pub mod error;
pub(crate) mod passes;
pub mod rehydrator;
pub(crate) mod schema_utils;

use serde::{Deserialize, Serialize};
use serde_json::Value;

pub use codec::Codec;
pub use codec_warning::Warning;
pub use config::{ConvertOptions, Mode, PolymorphismStrategy, Target};
pub use error::{ConvertError, ErrorCode, ProviderCompatError};
pub use rehydrator::{coerce_types, RehydrateResult};
pub use schema_utils::{build_path, escape_pointer_segment, split_path, unescape_pointer_segment};

/// Bridge API version. Included in all FFI JSON responses.
pub const API_VERSION: &str = "1.0";

/// Result of a schema conversion.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConvertResult {
    /// The converted LLM-compatible schema.
    pub schema: Value,
    /// The rehydration codec (sidecar metadata).
    pub codec: Codec,
    /// Provider compatibility warnings/soft-errors.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub provider_compat_errors: Vec<ProviderCompatError>,
}

/// Convert a JSON Schema into an LLM-compatible structured output schema.
///
/// # Arguments
///
/// * `schema` - A JSON Schema (Draft 2020-12 or earlier)
/// * `options` - Configuration for target provider, passes to skip, etc.
///
/// # Returns
///
/// A `ConvertResult` containing the converted schema and codec.
pub fn convert(schema: &Value, options: &ConvertOptions) -> Result<ConvertResult, ConvertError> {
    let mut codec = Codec::new();

    // Pass 0: Normalize ($ref resolution, draft migration)
    let p0 = passes::p0_normalize::normalize(schema, options)?;
    let mut schema = p0.schema;

    if !p0.recursive_refs.is_empty() {
        tracing::debug!(
            recursive_refs = ?p0.recursive_refs,
            "detected {} recursive $ref cycle(s) — will be broken in Pass 5",
            p0.recursive_refs.len()
        );
    }

    // Pass 1: Composition (allOf merge)
    let (s, dropped) = passes::p1_composition::compile_composition(&schema, options)?;
    schema = s;
    codec.dropped_constraints.extend(dropped);

    // Pass 2: Polymorphism (oneOf → anyOf)
    let p2 = passes::p2_polymorphism::simplify_polymorphism(&schema, options)?;
    schema = p2.schema;

    // Pass 3: Dictionary (Map → Array)
    let p3 = passes::p3_dictionary::transpile_dictionaries(&schema, options)?;
    schema = p3.schema;
    codec.transforms.extend(p3.transforms);

    // Pass 4: Opaque (open objects → string)
    let p4 = passes::p4_opaque::stringify_opaque(&schema, options)?;
    schema = p4.schema;
    codec.transforms.extend(p4.transforms);

    // Pass 5: Recursion Breaking
    let p5 = passes::p5_recursion::break_recursion(&schema, options)?;
    schema = p5.schema;
    codec.transforms.extend(p5.transforms);

    // Pass 6: Strict enforcement
    if options.mode == Mode::Strict {
        let p6 = passes::p6_strict::enforce_strict(&schema, options)?;
        schema = p6.schema;
        codec.transforms.extend(p6.transforms);
    }

    // Pass 7: Constraint pruning
    let p7 = passes::p7_constraints::prune_constraints(&schema, options)?;
    schema = p7.schema;
    codec.dropped_constraints.extend(p7.dropped_constraints);

    // Pass 9: Provider compatibility checks (soft errors)
    let p9 = passes::p9_provider_compat::check_provider_compat(&schema, options);
    schema = p9.schema;
    codec.transforms.extend(p9.transforms);

    Ok(ConvertResult {
        schema,
        codec,
        provider_compat_errors: p9.errors,
    })
}

/// Rehydrate LLM output back to the original schema shape using the codec.
///
/// # Arguments
///
/// * `data` - The JSON data generated by the LLM
/// * `codec` - The codec sidecar from conversion
///
/// # Returns
///
/// A [`RehydrateResult`] containing the rehydrated data and any advisory warnings
/// about constraint violations encountered during rehydration. Warnings do not
/// cause rehydration to fail; they are intended for logging or inspection.
///
/// # Examples
///
/// ```rust,no_run
/// use jsonschema_llm_core::{rehydrate, Codec};
/// use serde_json::json;
///
/// // In practice, obtain `codec` from a prior `convert(...)` call.
/// let codec = Codec::new();
/// let llm_output = json!({"name": "Ada", "age": 36});
///
/// let result = rehydrate(&llm_output, &codec).unwrap();
///
/// // Access the rehydrated data.
/// let data = &result.data;
///
/// // Inspect any advisory warnings (constraint violations, unevaluable constraints).
/// for warning in &result.warnings {
///     eprintln!("warning at {}: {}", warning.data_path, warning.message);
/// }
/// ```
pub fn rehydrate(data: &Value, codec: &Codec) -> Result<RehydrateResult, ConvertError> {
    rehydrator::rehydrate(data, codec)
}

// ---------------------------------------------------------------------------
// JSON-String Bridge API (FFI surface)
// ---------------------------------------------------------------------------

/// Format a `ConvertError` as a JSON string for FFI consumers.
fn err_json(e: ConvertError) -> String {
    e.to_json().to_string()
}

// ---------------------------------------------------------------------------
// Bridge Wrapper DTOs — inject apiVersion for FFI consumers
// ---------------------------------------------------------------------------

/// FFI envelope for conversion results. Injects `apiVersion` into the JSON output
/// while keeping `ConvertResult` clean for Rust consumers.
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct BridgeConvertResult<'a> {
    api_version: &'static str,
    #[serde(flatten)]
    inner: &'a ConvertResult,
}

/// FFI envelope for rehydration results. Injects `apiVersion` into the JSON output
/// while keeping `RehydrateResult` clean for Rust consumers.
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct BridgeRehydrateResult<'a> {
    api_version: &'static str,
    #[serde(flatten)]
    inner: &'a RehydrateResult,
}

/// Convert a JSON Schema (as a JSON string) with options (as a JSON string).
///
/// This is the FFI-friendly entry point — accepts and returns plain JSON strings.
/// The typed [`convert`] API remains available for Rust consumers.
///
/// # Arguments
///
/// * `schema_json` — A JSON Schema document as a string
/// * `options_json` — Conversion options as a JSON string. Fields use `kebab-case`
///   naming (e.g. `"max-depth"`, `"recursion-limit"`). Numeric options (`max_depth`,
///   `recursion_limit`) are deserialized as `usize`; values exceeding the platform's
///   pointer width will produce a deserialization error.
///
/// # Returns
///
/// * `Ok(String)` — `{"apiVersion": "1.0", "schema": {...}, "codec": {...}}`
/// * `Err(String)` — `{"code": "...", "message": "...", "path": ...}`
pub fn convert_json(schema_json: &str, options_json: &str) -> Result<String, String> {
    let schema: Value =
        serde_json::from_str(schema_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let options: ConvertOptions =
        serde_json::from_str(options_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let result = convert(&schema, &options).map_err(err_json)?;
    let bridge = BridgeConvertResult {
        api_version: API_VERSION,
        inner: &result,
    };
    serde_json::to_string(&bridge).map_err(|e| err_json(ConvertError::JsonError(e)))
}

/// Rehydrate LLM output (as a JSON string) using a codec (as a JSON string).
///
/// This is the FFI-friendly entry point — accepts and returns plain JSON strings.
/// The typed [`rehydrate`] API remains available for Rust consumers.
///
/// # Arguments
///
/// * `data_json` — The LLM-generated JSON data as a string
/// * `codec_json` — The codec sidecar (from a prior conversion) as a JSON string
///
/// # Returns
///
/// * `Ok(String)` — `{"apiVersion": "1.0", "data": {...}, "warnings": [...]}`
/// * `Err(String)` — `{"code": "...", "message": "...", "path": ...}`
pub fn rehydrate_json(data_json: &str, codec_json: &str) -> Result<String, String> {
    let data: Value =
        serde_json::from_str(data_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let codec: Codec =
        serde_json::from_str(codec_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let result = rehydrate(&data, &codec).map_err(err_json)?;
    let bridge = BridgeRehydrateResult {
        api_version: API_VERSION,
        inner: &result,
    };
    serde_json::to_string(&bridge).map_err(|e| err_json(ConvertError::JsonError(e)))
}
