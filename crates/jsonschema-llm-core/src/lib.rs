//! # jsonschema-llm-core
//!
//! Convert any JSON Schema (Draft 2020-12) into an LLM-compatible
//! structured output schema with full round-trip rehydration support.
//!
//! ## Quick Start
//!
//! ```rust,no_run
//! use jsonschema_llm_core::{convert, ConvertOptions, Target};
//!
//! let schema = serde_json::json!({
//!     "type": "object",
//!     "properties": {
//!         "name": { "type": "string" },
//!         "age": { "type": "integer", "minimum": 0 }
//!     },
//!     "required": ["name"]
//! });
//!
//! let result = convert(&schema, &ConvertOptions::default()).unwrap();
//! println!("Converted: {}", serde_json::to_string_pretty(&result.schema).unwrap());
//! println!("Codec: {}", serde_json::to_string_pretty(&result.codec).unwrap());
//! ```

pub mod codec;
pub mod codec_warning;
pub mod config;
pub mod error;
pub(crate) mod passes;
pub mod rehydrator;
pub(crate) mod schema_utils;

use serde_json::Value;

pub use codec::Codec;
pub use codec_warning::Warning;
pub use config::{ConvertOptions, Target};
pub use error::ConvertError;
pub use rehydrator::RehydrateResult;
pub use schema_utils::{build_path, escape_pointer_segment, split_path, unescape_pointer_segment};

/// Result of a schema conversion.
pub struct ConvertResult {
    /// The converted LLM-compatible schema.
    pub schema: Value,
    /// The rehydration codec (sidecar metadata).
    pub codec: Codec,
}

/// Convert a JSON Schema into an LLM-compatible structured output schema.
///
/// # Arguments
///
/// * `schema` - A JSON Schema (Draft 2020-12 or earlier)
/// * `options` - Configuration for target provider, passes to skip, etc.
///
/// # Returns
///
/// A `ConvertResult` containing the converted schema and codec.
pub fn convert(schema: &Value, options: &ConvertOptions) -> Result<ConvertResult, ConvertError> {
    let mut codec = Codec::new();

    // Pass 0: Normalize ($ref resolution, draft migration)
    let p0 = passes::p0_normalize::normalize(schema, options)?;
    let mut schema = p0.schema;

    // Pass 1: Composition (allOf merge)
    let (s, dropped) = passes::p1_composition::compile_composition(&schema, options)?;
    schema = s;
    codec.dropped_constraints.extend(dropped);

    // Pass 2: Polymorphism (oneOf → anyOf)
    let p2 = passes::p2_polymorphism::simplify_polymorphism(&schema, options)?;
    schema = p2.schema;

    // Pass 3: Dictionary (Map → Array)
    let p3 = passes::p3_dictionary::transpile_dictionaries(&schema, options)?;
    schema = p3.schema;
    codec.transforms.extend(p3.transforms);

    // Pass 4: Opaque (open objects → string)
    let p4 = passes::p4_opaque::stringify_opaque(&schema, options)?;
    schema = p4.schema;
    codec.transforms.extend(p4.transforms);

    // Pass 5: Recursion Breaking
    let p5 = passes::p5_recursion::break_recursion(&schema, options)?;
    schema = p5.schema;
    codec.transforms.extend(p5.transforms);

    // Pass 6: Strict enforcement
    let p6 = passes::p6_strict::enforce_strict(&schema, options)?;
    schema = p6.schema;
    codec.transforms.extend(p6.transforms);

    // Pass 7: Constraint pruning
    let p7 = passes::p7_constraints::prune_constraints(&schema, options)?;
    schema = p7.schema;
    codec.dropped_constraints.extend(p7.dropped_constraints);

    Ok(ConvertResult { schema, codec })
}

/// Rehydrate LLM output back to the original schema shape using the codec.
///
/// # Arguments
///
/// * `data` - The JSON data generated by the LLM
/// * `codec` - The codec sidecar from conversion
///
/// # Returns
///
/// A [`RehydrateResult`] containing the rehydrated data and any advisory warnings
/// about constraint violations encountered during rehydration. Warnings do not
/// cause rehydration to fail; they are intended for logging or inspection.
///
/// # Examples
///
/// ```rust,no_run
/// use jsonschema_llm_core::{rehydrate, Codec};
/// use serde_json::json;
///
/// // In practice, obtain `codec` from a prior `convert(...)` call.
/// let codec = Codec::new();
/// let llm_output = json!({"name": "Ada", "age": 36});
///
/// let result = rehydrate(&llm_output, &codec).unwrap();
///
/// // Access the rehydrated data.
/// let data = &result.data;
///
/// // Inspect any advisory warnings (constraint violations, unevaluable constraints).
/// for warning in &result.warnings {
///     eprintln!("warning at {}: {}", warning.data_path, warning.message);
/// }
/// ```
pub fn rehydrate(data: &Value, codec: &Codec) -> Result<RehydrateResult, ConvertError> {
    rehydrator::rehydrate(data, codec)
}
