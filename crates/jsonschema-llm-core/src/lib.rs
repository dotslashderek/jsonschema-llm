//! # jsonschema-llm-core
//!
//! Convert any JSON Schema (Draft 2020-12) into an LLM-compatible
//! structured output schema with full round-trip rehydration support.
//!
//! ## Quick Start
//!
//! ```rust,no_run
//! use jsonschema_llm_core::{convert, ConvertOptions, Target};
//!
//! let schema = serde_json::json!({
//!     "type": "object",
//!     "properties": {
//!         "name": { "type": "string" },
//!         "age": { "type": "integer", "minimum": 0 }
//!     },
//!     "required": ["name"]
//! });
//!
//! let result = convert(&schema, &ConvertOptions::default()).unwrap();
//! println!("Converted: {}", serde_json::to_string_pretty(&result.schema).unwrap());
//! println!("Codec: {}", serde_json::to_string_pretty(&result.codec).unwrap());
//! ```

pub mod codec;
pub mod codec_warning;
pub mod config;
pub mod error;
pub mod extract;
pub(crate) mod passes;
pub mod rehydrator;
pub(crate) mod schema_utils;

use serde::{Deserialize, Serialize};
use serde_json::Value;

pub use codec::Codec;
pub use codec_warning::Warning;
pub use config::{ConvertOptions, Mode, PolymorphismStrategy, Target};
pub use error::{ConvertError, ErrorCode, ProviderCompatError};
pub use extract::{extract_component, list_components, ExtractOptions, ExtractResult};
pub use rehydrator::{coerce_types, RehydrateResult};
pub use schema_utils::{build_path, escape_pointer_segment, split_path, unescape_pointer_segment};

/// Bridge API version. Included in all FFI JSON responses.
pub const API_VERSION: &str = "1.0";

/// Result of a schema conversion.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConvertResult {
    /// The converted LLM-compatible schema.
    pub schema: Value,
    /// The rehydration codec (sidecar metadata).
    pub codec: Codec,
    /// Provider compatibility warnings/soft-errors.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub provider_compat_errors: Vec<ProviderCompatError>,
}

/// Convert a JSON Schema into an LLM-compatible structured output schema.
///
/// # Arguments
///
/// * `schema` - A JSON Schema (Draft 2020-12 or earlier)
/// * `options` - Configuration for target provider, passes to skip, etc.
///
/// # Returns
///
/// A `ConvertResult` containing the converted schema and codec.
pub fn convert(schema: &Value, options: &ConvertOptions) -> Result<ConvertResult, ConvertError> {
    let mut codec = Codec::new();

    // Pass 0: Normalize ($ref resolution, draft migration)
    let p0 = passes::p0_normalize::normalize(schema, options)?;
    let schema = p0.pass.schema;

    if !p0.recursive_refs.is_empty() {
        tracing::debug!(
            recursive_refs = ?p0.recursive_refs,
            "detected {} recursive $ref cycle(s) — will be broken in Pass 5",
            p0.recursive_refs.len()
        );
    }

    // Pass 1: Composition (allOf merge)
    let p1 = passes::p1_composition::compile_composition(schema, options)?;
    let schema = p1.merge_into_codec(&mut codec);

    // Pass 2: Polymorphism (oneOf → anyOf)
    let p2 = passes::p2_polymorphism::simplify_polymorphism(schema, options)?;
    let schema = p2.merge_into_codec(&mut codec);

    // Pass 3: Dictionary (Map → Array)
    let p3 = passes::p3_dictionary::transpile_dictionaries(schema, options)?;
    let schema = p3.merge_into_codec(&mut codec);

    // Pass 4: Opaque (open objects → string)
    let p4 = passes::p4_opaque::stringify_opaque(schema, options)?;
    let schema = p4.merge_into_codec(&mut codec);

    // Pass 5: Recursion Breaking
    let p5 = passes::p5_recursion::break_recursion(schema, options)?;
    let mut schema = p5.merge_into_codec(&mut codec);

    // Pass 6: Strict enforcement
    if options.mode == Mode::Strict {
        let p6 = passes::p6_strict::enforce_strict(schema, options)?;
        schema = p6.merge_into_codec(&mut codec);
    }

    // Pass 8: Adaptive opaque stringification (before constraint pruning
    // so it can detect `contains`, closed-tuple `prefixItems`, etc.)
    let p8 = passes::p8_adaptive_opaque::adaptive_opaque(schema, options)?;
    let schema = p8.merge_into_codec(&mut codec);

    // Pass 7: Constraint pruning
    let p7 = passes::p7_constraints::prune_constraints(schema, options)?;
    let schema = p7.merge_into_codec(&mut codec);

    // Pass 9: Provider compatibility checks (soft errors)
    let p9 = passes::p9_provider_compat::check_provider_compat(schema, options);
    let provider_compat_errors = p9.errors;
    let schema = p9.pass.merge_into_codec(&mut codec);

    Ok(ConvertResult {
        schema,
        codec,
        provider_compat_errors,
    })
}

/// Rehydrate LLM output back to the original schema shape using the codec.
///
/// Type coercion is always applied using the provided `original_schema`
/// to fix LLM type mismatches (e.g. `"42"` where `integer` was expected).
///
/// # Arguments
///
/// * `data` - The JSON data generated by the LLM
/// * `codec` - The codec sidecar from conversion
/// * `original_schema` - The original JSON Schema (before conversion) used for type coercion
///
/// # Returns
///
/// A [`RehydrateResult`] containing the rehydrated data and any advisory warnings
/// about constraint violations or type coercions encountered during rehydration.
///
/// Warnings are *advisory only*: they never cause `rehydrate` to return `Err`
/// and are intended for logging, inspection, or telemetry rather than control flow.
///
/// # Examples
///
/// ```rust,no_run
/// use jsonschema_llm_core::{convert, rehydrate, ConvertOptions};
/// use serde_json::json;
///
/// let schema = json!({"type": "object", "properties": {"name": {"type": "string"}}});
/// let options = ConvertOptions::default();
/// let result = convert(&schema, &options).unwrap();
///
/// let llm_output = json!({"name": "Ada"});
/// let rehydrated = rehydrate(&llm_output, &result.codec, &schema).unwrap();
/// ```
///
/// # Warning Ordering
///
/// Warnings follow a deterministic phase-group order:
/// 1. Type coercion warnings (value type adjusted to match schema)
/// 2. Constraint enforcement warnings (value clamped/truncated to satisfy bounds)
/// 3. Constraint validation warnings (advisory: value violates a dropped constraint)
///
/// Enforcement may **auto-correct** values (e.g., clamping an integer that exceeds
/// `maximum`). Validation warnings are advisory-only and do not modify the data.
pub fn rehydrate(
    data: &Value,
    codec: &Codec,
    original_schema: &Value,
) -> Result<RehydrateResult, ConvertError> {
    // Phase 1: Apply transforms (reverse codec operations)
    let mut result = rehydrator::apply_transforms(data, codec)?;

    // Phase 2: Type coercion (e.g., string "42" → integer 42)
    let coercion_warnings = rehydrator::coerce_types(&mut result.data, original_schema);
    result.warnings.extend(coercion_warnings);

    // Phase 3: Constraint enforcement + validation (runs AFTER coercion so
    // constraints evaluate against correctly-typed values)
    let regex_cache = rehydrator::build_pattern_properties_cache(codec);
    let enforcement_warnings =
        rehydrator::enforce_constraints(&mut result.data, codec, &regex_cache);
    let validation_warnings = rehydrator::validate_constraints(&result.data, codec, &regex_cache);
    result.warnings.extend(enforcement_warnings);
    result.warnings.extend(validation_warnings);

    Ok(result)
}

/// Result of a [`convert_all_components`] call.
///
/// Contains the full-schema conversion and, unless suppressed via
/// [`ConvertOptions::skip_components`], per-component results sorted by
/// JSON Pointer.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConvertAllResult {
    /// Conversion result for the entire input schema.
    pub full: ConvertResult,
    /// Per-component results as `(pointer, ConvertResult)` pairs, sorted by pointer.
    ///
    /// Empty when [`ConvertOptions::skip_components`] is `true`.
    pub components: Vec<(String, ConvertResult)>,
    /// Per-component failures as `(pointer, error_message)` pairs.
    ///
    /// Individual errors do not abort the batch — components that succeed still
    /// appear in `components`. Sorted by pointer for deterministic output.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub component_errors: Vec<(String, String)>,
}

/// Convert an entire schema *and* each of its components in one call.
///
/// This is a thin orchestration layer:
/// 1. Always runs [`convert`] on the full `schema` → [`ConvertAllResult::full`]
/// 2. Unless [`ConvertOptions::skip_components`] is `true`: calls
///    [`list_components`] → for each pointer calls [`extract_component`] then
///    [`convert`] on the extracted sub-schema
/// 3. Per-component errors are collected in [`ConvertAllResult::component_errors`]
///    and do not abort the batch
///
/// # Performance Note
///
/// Extraction is `O(N × Schema_Size)` — each call traverses the full schema.
/// For very large OAS documents with hundreds of components, this may be slow.
/// See [#190](<https://github.com/dotslashderek/jsonschema-llm/issues/190>) for
/// the tracked optimisation.
pub fn convert_all_components(
    schema: &Value,
    convert_options: &ConvertOptions,
    extract_options: &ExtractOptions,
) -> Result<ConvertAllResult, ConvertError> {
    // Step 1: Always convert the full schema.
    let full = convert(schema, convert_options)?;

    // Step 2: Early-exit if component extraction is suppressed.
    if convert_options.skip_components {
        return Ok(ConvertAllResult {
            full,
            components: Vec::new(),
            component_errors: Vec::new(),
        });
    }

    // Step 3: Enumerate and process each component — best-effort.
    let pointers = list_components(schema);
    let mut components: Vec<(String, ConvertResult)> = Vec::with_capacity(pointers.len());
    let mut component_errors: Vec<(String, String)> = Vec::new();

    for pointer in pointers {
        let extract_result = extract_component(schema, &pointer, extract_options);
        match extract_result {
            Err(e) => {
                component_errors.push((pointer, e.to_string()));
            }
            Ok(extracted) => match convert(&extracted.schema, convert_options) {
                Err(e) => {
                    component_errors.push((pointer, e.to_string()));
                }
                Ok(conv) => {
                    components.push((pointer, conv));
                }
            },
        }
    }

    // Sort errors for deterministic output.
    component_errors.sort_by(|(a, _), (b, _)| a.cmp(b));

    Ok(ConvertAllResult {
        full,
        components,
        component_errors,
    })
}

// ---------------------------------------------------------------------------
// JSON-String Bridge API (FFI surface)
// ---------------------------------------------------------------------------

/// Format a `ConvertError` as a JSON string for FFI consumers.
fn err_json(e: ConvertError) -> String {
    e.to_json().to_string()
}

// ---------------------------------------------------------------------------
// Bridge Wrapper DTOs — inject apiVersion for FFI consumers
// ---------------------------------------------------------------------------

/// FFI envelope for conversion results. Injects `apiVersion` into the JSON output
/// while keeping `ConvertResult` clean for Rust consumers.
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct BridgeConvertResult<'a> {
    api_version: &'static str,
    #[serde(flatten)]
    inner: &'a ConvertResult,
}

/// FFI envelope for rehydration results. Injects `apiVersion` into the JSON output
/// while keeping `RehydrateResult` clean for Rust consumers.
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct BridgeRehydrateResult<'a> {
    api_version: &'static str,
    #[serde(flatten)]
    inner: &'a RehydrateResult,
}

/// Convert a JSON Schema (as a JSON string) with options (as a JSON string).
///
/// This is the FFI-friendly entry point — accepts and returns plain JSON strings.
/// The typed [`convert`] API remains available for Rust consumers.
///
/// # Arguments
///
/// * `schema_json` — A JSON Schema document as a string
/// * `options_json` — Conversion options as a JSON string. Fields use `kebab-case`
///   naming (e.g. `"max-depth"`, `"recursion-limit"`). Numeric options (`max_depth`,
///   `recursion_limit`) are deserialized as `usize`; values exceeding the platform's
///   pointer width will produce a deserialization error.
///
/// # Returns
///
/// * `Ok(String)` — `{"apiVersion": "1.0", "schema": {...}, "codec": {...}}`
/// * `Err(String)` — `{"code": "...", "message": "...", "path": ...}`
pub fn convert_json(schema_json: &str, options_json: &str) -> Result<String, String> {
    let schema: Value =
        serde_json::from_str(schema_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let options: ConvertOptions =
        serde_json::from_str(options_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let result = convert(&schema, &options).map_err(err_json)?;
    let bridge = BridgeConvertResult {
        api_version: API_VERSION,
        inner: &result,
    };
    serde_json::to_string(&bridge).map_err(|e| err_json(ConvertError::JsonError(e)))
}

/// Rehydrate LLM output (as a JSON string) using a codec and original schema.
///
/// This is the FFI-friendly entry point — accepts and returns plain JSON strings.
/// The typed [`rehydrate`] API remains available for Rust consumers.
///
/// # Arguments
///
/// * `data_json` — The LLM-generated JSON data as a string
/// * `codec_json` — The codec sidecar (from a prior conversion) as a JSON string
/// * `original_schema_json` — The original JSON Schema as a string (for type coercion)
///
/// # Returns
///
/// * `Ok(String)` — `{"apiVersion": "1.0", "data": {...}, "warnings": [...]}`
/// * `Err(String)` — `{"code": "...", "message": "...", "path": ...}`
pub fn rehydrate_json(
    data_json: &str,
    codec_json: &str,
    original_schema_json: &str,
) -> Result<String, String> {
    let data: Value =
        serde_json::from_str(data_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let codec: Codec =
        serde_json::from_str(codec_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let original_schema: Value = serde_json::from_str(original_schema_json)
        .map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let result = rehydrate(&data, &codec, &original_schema).map_err(err_json)?;
    let bridge = BridgeRehydrateResult {
        api_version: API_VERSION,
        inner: &result,
    };
    serde_json::to_string(&bridge).map_err(|e| err_json(ConvertError::JsonError(e)))
}

/// FFI envelope for `convert_all_components` results. Injects `apiVersion` for FFI consumers.
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct BridgeConvertAllResult<'a> {
    api_version: &'static str,
    #[serde(flatten)]
    inner: &'a ConvertAllResult,
}

/// List all extractable component JSON Pointers in a schema (as a JSON string).
///
/// This is the FFI-friendly entry point — accepts and returns plain JSON strings.
/// The typed [`list_components`] API remains available for Rust consumers.
///
/// # Arguments
///
/// * `schema_json` — A JSON Schema document as a string
///
/// # Returns
///
/// * `Ok(String)` — `{"apiVersion": "1.0", "components": ["#/$defs/Foo", ...]}`
/// * `Err(String)` — `{"code": "...", "message": "...", "path": ...}`
pub fn list_components_json(schema_json: &str) -> Result<String, String> {
    let schema: Value =
        serde_json::from_str(schema_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let components = list_components(&schema);
    let result = serde_json::json!({
        "apiVersion": API_VERSION,
        "components": components,
    });
    serde_json::to_string(&result).map_err(|e| err_json(ConvertError::JsonError(e)))
}

/// Extract a single component from a schema by JSON Pointer (as a JSON string).
///
/// This is the FFI-friendly entry point — accepts and returns plain JSON strings.
/// The typed [`extract_component`] API remains available for Rust consumers.
///
/// # Arguments
///
/// * `schema_json` — A JSON Schema document as a string
/// * `pointer` — RFC 6901 JSON Pointer to the component (e.g. `#/$defs/Pet`)
/// * `options_json` — Extraction options as a JSON string (kebab-case keys).
///   Pass `"{}"` for defaults.
///
/// # Returns
///
/// * `Ok(String)` — `{"apiVersion": "1.0", "schema": {...}, "pointer": "...", ...}`
/// * `Err(String)` — `{"code": "...", "message": "...", "path": ...}`
pub fn extract_component_json(
    schema_json: &str,
    pointer: &str,
    options_json: &str,
) -> Result<String, String> {
    let schema: Value =
        serde_json::from_str(schema_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let options: extract::ExtractOptions =
        serde_json::from_str(options_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let result = extract_component(&schema, pointer, &options).map_err(err_json)?;
    let envelope = serde_json::json!({
        "apiVersion": API_VERSION,
        "schema": result.schema,
        "pointer": result.pointer,
        "dependencyCount": result.dependency_count,
        "missingRefs": result.missing_refs,
    });
    serde_json::to_string(&envelope).map_err(|e| err_json(ConvertError::JsonError(e)))
}

/// Convert a JSON Schema and all its components in a single call (as JSON strings).
///
/// This is the FFI-friendly entry point — accepts and returns plain JSON strings.
/// The typed [`convert_all_components`] API remains available for Rust consumers.
///
/// # Arguments
///
/// * `schema_json` — A JSON Schema document as a string
/// * `convert_options_json` — Conversion options as a JSON string (kebab-case keys).
///   Pass `"{}"` for defaults.
/// * `extract_options_json` — Extraction options as a JSON string (kebab-case keys).
///   Pass `"{}"` for defaults.
///
/// # Returns
///
/// * `Ok(String)` — `{"apiVersion": "1.0", "full": {...}, "components": [...], ...}`
/// * `Err(String)` — `{"code": "...", "message": "...", "path": ...}`
pub fn convert_all_components_json(
    schema_json: &str,
    convert_options_json: &str,
    extract_options_json: &str,
) -> Result<String, String> {
    let schema: Value =
        serde_json::from_str(schema_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let convert_options: ConvertOptions = serde_json::from_str(convert_options_json)
        .map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let extract_options: extract::ExtractOptions = serde_json::from_str(extract_options_json)
        .map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let result =
        convert_all_components(&schema, &convert_options, &extract_options).map_err(err_json)?;
    let bridge = BridgeConvertAllResult {
        api_version: API_VERSION,
        inner: &result,
    };
    serde_json::to_string(&bridge).map_err(|e| err_json(ConvertError::JsonError(e)))
}

// ===========================================================================
// Tests (TDD — written before implementation)
// ===========================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    fn default_opts() -> ConvertOptions {
        ConvertOptions::default()
    }

    fn default_extract_opts() -> ExtractOptions {
        ExtractOptions::default()
    }

    // -----------------------------------------------------------------------
    // convert_all_components() — TDD gate tests (#176)
    // -----------------------------------------------------------------------

    #[test]
    fn test_convert_all_empty_schema() {
        let schema = json!({ "type": "object", "properties": { "x": { "type": "integer" } } });
        let result = convert_all_components(&schema, &default_opts(), &default_extract_opts())
            .expect("convert_all_components should not error on a schema with no components");
        assert!(result.components.is_empty(), "no $defs → empty components");
        assert!(result.component_errors.is_empty());
        // full schema always present
        assert!(result.full.schema.is_object());
    }

    #[test]
    fn test_convert_all_three_defs() {
        let schema = json!({
            "$defs": {
                "A": { "type": "string" },
                "B": { "type": "integer" },
                "C": { "type": "boolean" }
            }
        });
        let result = convert_all_components(&schema, &default_opts(), &default_extract_opts())
            .expect("convert_all_components should succeed");
        // full is always present
        assert!(result.full.schema.is_object());
        // 3 components
        assert_eq!(
            result.components.len(),
            3,
            "expected 3 component results; got: {:?}",
            result.components.iter().map(|(p, _)| p).collect::<Vec<_>>()
        );
        // all components have a valid schema
        for (pointer, conv_result) in &result.components {
            assert!(
                conv_result.schema.is_object(),
                "component {} schema should be an object",
                pointer
            );
        }
        // no errors
        assert!(result.component_errors.is_empty());
    }

    #[test]
    fn test_convert_all_skip_components_flag() {
        let schema = json!({
            "$defs": {
                "A": { "type": "string" },
                "B": { "type": "integer" }
            }
        });
        let mut opts = default_opts();
        opts.skip_components = true;
        let result = convert_all_components(&schema, &opts, &default_extract_opts())
            .expect("convert_all_components should succeed with skip_components=true");
        // full always present
        assert!(result.full.schema.is_object());
        // components vec must be empty
        assert!(
            result.components.is_empty(),
            "skip_components=true should yield empty components"
        );
        assert!(result.component_errors.is_empty());
    }

    #[test]
    fn test_convert_all_partial_failure_best_effort() {
        // Use a tight max_depth so a component with a deep $ref chain fails at
        // extraction while simpler components succeed. This exercises the
        // best-effort error collection in convert_all_components().
        let schema = json!({
            "$defs": {
                // This component has a 2-hop ref chain: Deep → Mid → Leaf
                // With max_depth=1, the second hop (Leaf) will exceed the limit.
                "Deep": { "$ref": "#/$defs/Mid" },
                "Mid":  { "$ref": "#/$defs/Leaf" },
                "Leaf": { "type": "string" },
                "Good": { "type": "integer" }
            }
        });
        // max_depth=1 means exactly one $ref hop is allowed.
        // Extracting "Deep" tries to follow Deep→Mid (hop 1) then Mid→Leaf (hop 2) → error.
        // Extracting "Good", "Mid", and "Leaf" all succeed.
        let tight_extract = ExtractOptions { max_depth: Some(1) };
        let result = convert_all_components(&schema, &default_opts(), &tight_extract)
            .expect("convert_all_components itself should not fail");
        // Good component must succeed
        let good = result.components.iter().find(|(p, _)| p == "#/$defs/Good");
        assert!(
            good.is_some(),
            "Good component should succeed; components: {:?}",
            result.components.iter().map(|(p, _)| p).collect::<Vec<_>>()
        );
        // Deep must be in component_errors (exceeded max_depth)
        let deep_err = result
            .component_errors
            .iter()
            .find(|(p, _)| p == "#/$defs/Deep");
        assert!(
            deep_err.is_some(),
            "#/$defs/Deep should appear in component_errors; errors: {:?}",
            result.component_errors
        );
    }

    #[test]
    fn test_convert_all_component_codec_rehydrates() {
        // Each component's codec should be usable to rehydrate LLM output.
        let schema = json!({
            "$defs": {
                "Pet": {
                    "type": "object",
                    "properties": {
                        "name": { "type": "string" },
                        "age":  { "type": "integer" }
                    },
                    "required": ["name"]
                }
            }
        });
        let result = convert_all_components(&schema, &default_opts(), &default_extract_opts())
            .expect("convert_all_components should succeed");
        let (_ptr, pet_result) = result
            .components
            .iter()
            .find(|(p, _)| p == "#/$defs/Pet")
            .expect("#/$defs/Pet should be present");
        // Use the extracted schema as the original for rehydration
        let llm_output = json!({ "name": "Fido", "age": 3 });
        let rehydrated = rehydrate(&llm_output, &pet_result.codec, &pet_result.schema);
        assert!(
            rehydrated.is_ok(),
            "rehydrate() on component codec should succeed: {:?}",
            rehydrated.unwrap_err()
        );
    }

    // -----------------------------------------------------------------------
    // skip_components in ConvertOptions serde round-trip (#176)
    // -----------------------------------------------------------------------

    #[test]
    fn test_skip_components_serde_round_trip() {
        let opts = ConvertOptions {
            skip_components: true,
            ..ConvertOptions::default()
        };
        let json = serde_json::to_string(&opts).unwrap();
        assert!(
            json.contains("\"skip-components\""),
            "kebab-case field expected; got: {}",
            json
        );
        let deserialized: ConvertOptions = serde_json::from_str(&json).unwrap();
        assert!(deserialized.skip_components);
    }

    #[test]
    fn test_skip_components_defaults_false() {
        let opts = ConvertOptions::default();
        assert!(!opts.skip_components);
    }

    // -----------------------------------------------------------------------
    // Bridge JSON API — unit tests (#177)
    // -----------------------------------------------------------------------

    #[test]
    fn test_list_components_json_returns_sorted_pointers() {
        let schema = json!({
            "$defs": {
                "B": { "type": "integer" },
                "A": { "type": "string" }
            }
        });
        let schema_json = serde_json::to_string(&schema).unwrap();
        let result =
            list_components_json(&schema_json).expect("list_components_json should succeed");
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
        assert_eq!(parsed["apiVersion"], "1.0");
        let components = parsed["components"].as_array().unwrap();
        assert_eq!(components.len(), 2);
        // Sorted A < B
        assert_eq!(components[0], "#/$defs/A");
        assert_eq!(components[1], "#/$defs/B");
    }

    #[test]
    fn test_list_components_json_empty_schema() {
        let schema_json = r#"{"type": "object"}"#;
        let result = list_components_json(schema_json).expect("should succeed on plain schema");
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
        assert!(parsed["components"].as_array().unwrap().is_empty());
    }

    #[test]
    fn test_list_components_json_invalid_json_returns_err() {
        let result = list_components_json("not json");
        assert!(result.is_err(), "invalid JSON should return Err");
        let err: serde_json::Value = serde_json::from_str(&result.unwrap_err()).unwrap();
        assert!(err.get("code").is_some(), "error should have a code field");
    }

    #[test]
    fn test_extract_component_json_happy_path() {
        let schema = json!({
            "$defs": {
                "Pet": { "type": "object", "properties": { "name": { "type": "string" } } },
                "Tag": { "type": "string" }
            }
        });
        let schema_json = serde_json::to_string(&schema).unwrap();
        let result = extract_component_json(&schema_json, "#/$defs/Pet", "{}")
            .expect("extract_component_json should succeed");
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
        assert_eq!(parsed["apiVersion"], "1.0");
        assert_eq!(parsed["pointer"], "#/$defs/Pet");
        assert!(parsed["schema"].is_object());
        assert_eq!(parsed["dependencyCount"], 0);
    }

    #[test]
    fn test_extract_component_json_missing_pointer_returns_err() {
        let schema = json!({ "$defs": { "Foo": { "type": "string" } } });
        let schema_json = serde_json::to_string(&schema).unwrap();
        let result = extract_component_json(&schema_json, "#/$defs/DoesNotExist", "{}");
        assert!(result.is_err(), "missing pointer should return Err");
        let err: serde_json::Value = serde_json::from_str(&result.unwrap_err()).unwrap();
        assert!(err.get("code").is_some());
    }

    #[test]
    fn test_extract_component_json_with_max_depth_option() {
        let schema = json!({
            "$defs": {
                "A": { "$ref": "#/$defs/B" },
                "B": { "$ref": "#/$defs/C" },
                "C": { "type": "string" }
            }
        });
        let schema_json = serde_json::to_string(&schema).unwrap();
        // max-depth=1 allows exactly 1 hop; A→B is hop 1, B→C is hop 2 → error
        let result = extract_component_json(&schema_json, "#/$defs/A", r#"{"max-depth": 1}"#);
        assert!(result.is_err(), "should fail with tight max-depth");
    }

    #[test]
    fn test_convert_all_components_json_happy_path() {
        let schema = json!({
            "$defs": {
                "X": { "type": "string" },
                "Y": { "type": "integer" }
            }
        });
        let schema_json = serde_json::to_string(&schema).unwrap();
        let result = convert_all_components_json(&schema_json, "{}", "{}")
            .expect("convert_all_components_json should succeed");
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
        assert_eq!(parsed["apiVersion"], "1.0");
        assert!(parsed["full"].is_object());
        let components = parsed["components"].as_array().unwrap();
        assert_eq!(components.len(), 2);
    }

    #[test]
    fn test_convert_all_components_json_invalid_schema_returns_err() {
        let result = convert_all_components_json("not json", "{}", "{}");
        assert!(result.is_err());
        let err: serde_json::Value = serde_json::from_str(&result.unwrap_err()).unwrap();
        assert!(err.get("code").is_some());
    }

    #[test]
    fn test_extract_options_serde_round_trip() {
        let opts = ExtractOptions { max_depth: Some(5) };
        let json = serde_json::to_string(&opts).unwrap();
        assert!(
            json.contains("\"max-depth\""),
            "kebab-case field expected; got: {}",
            json
        );
        let deserialized: ExtractOptions = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.max_depth, Some(5));
    }

    #[test]
    fn test_extract_options_defaults_to_none() {
        let opts = ExtractOptions::default();
        assert!(opts.max_depth.is_none());
    }
}
