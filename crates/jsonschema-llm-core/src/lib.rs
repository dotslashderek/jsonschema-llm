//! # jsonschema-llm-core
//!
//! Convert any JSON Schema (Draft 2020-12) into an LLM-compatible
//! structured output schema with full round-trip rehydration support.
//!
//! ## Quick Start
//!
//! ```rust,no_run
//! use jsonschema_llm_core::{convert, ConvertOptions, Target};
//!
//! let schema = serde_json::json!({
//!     "type": "object",
//!     "properties": {
//!         "name": { "type": "string" },
//!         "age": { "type": "integer", "minimum": 0 }
//!     },
//!     "required": ["name"]
//! });
//!
//! let result = convert(&schema, &ConvertOptions::default()).unwrap();
//! println!("Converted: {}", serde_json::to_string_pretty(&result.schema).unwrap());
//! println!("Codec: {}", serde_json::to_string_pretty(&result.codec).unwrap());
//! ```

pub mod codec;
pub mod codec_warning;
pub mod config;
pub mod error;
pub mod passes;
pub mod rehydrator;
pub mod schema_utils;

use serde_json::Value;

pub use codec::Codec;
pub use codec_warning::Warning;
pub use config::{ConvertOptions, Target};
pub use error::ConvertError;
pub use rehydrator::RehydrateResult;

/// Result of a schema conversion.
pub struct ConvertResult {
    /// The converted LLM-compatible schema.
    pub schema: Value,
    /// The rehydration codec (sidecar metadata).
    pub codec: Codec,
}

/// Convert a JSON Schema into an LLM-compatible structured output schema.
///
/// # Arguments
///
/// * `schema` - A JSON Schema (Draft 2020-12 or earlier)
/// * `options` - Configuration for target provider, passes to skip, etc.
///
/// # Returns
///
/// A `ConvertResult` containing the converted schema and codec.
pub fn convert(schema: &Value, options: &ConvertOptions) -> Result<ConvertResult, ConvertError> {
    let _ = (schema, options);
    todo!("Implementation coming soon")
}

/// Rehydrate LLM output back to the original schema shape using the codec.
///
/// # Arguments
///
/// * `data` - The JSON data generated by the LLM
/// * `codec` - The codec sidecar from conversion
///
/// # Returns
///
/// The rehydrated data with warnings about constraint violations.
pub fn rehydrate(data: &Value, codec: &Codec) -> Result<RehydrateResult, ConvertError> {
    rehydrator::rehydrate(data, codec)
}
