//! # jsonschema-llm-core
//!
//! Convert any JSON Schema (Draft 2020-12) into an LLM-compatible
//! structured output schema with full round-trip rehydration support.
//!
//! ## Quick Start
//!
//! ```rust,no_run
//! use jsonschema_llm_core::{convert, ConvertOptions, Target};
//!
//! let schema = serde_json::json!({
//!     "type": "object",
//!     "properties": {
//!         "name": { "type": "string" },
//!         "age": { "type": "integer", "minimum": 0 }
//!     },
//!     "required": ["name"]
//! });
//!
//! let result = convert(&schema, &ConvertOptions::default()).unwrap();
//! println!("Converted: {}", serde_json::to_string_pretty(&result.schema).unwrap());
//! println!("Codec: {}", serde_json::to_string_pretty(&result.codec).unwrap());
//! ```

pub mod codec;
pub mod codec_warning;
pub mod config;
pub mod error;
pub(crate) mod passes;
pub mod rehydrator;
pub(crate) mod schema_utils;

use serde::{Deserialize, Serialize};
use serde_json::Value;

pub use codec::Codec;
pub use codec_warning::Warning;
pub use config::{ConvertOptions, Mode, PolymorphismStrategy, Target};
pub use error::{ConvertError, ErrorCode, ProviderCompatError};
pub use rehydrator::{coerce_types, RehydrateResult};
pub use schema_utils::{build_path, escape_pointer_segment, split_path, unescape_pointer_segment};

/// Bridge API version. Included in all FFI JSON responses.
pub const API_VERSION: &str = "1.0";

/// Result of a schema conversion.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConvertResult {
    /// The converted LLM-compatible schema.
    pub schema: Value,
    /// The rehydration codec (sidecar metadata).
    pub codec: Codec,
    /// Provider compatibility warnings/soft-errors.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub provider_compat_errors: Vec<ProviderCompatError>,
}

/// Convert a JSON Schema into an LLM-compatible structured output schema.
///
/// # Arguments
///
/// * `schema` - A JSON Schema (Draft 2020-12 or earlier)
/// * `options` - Configuration for target provider, passes to skip, etc.
///
/// # Returns
///
/// A `ConvertResult` containing the converted schema and codec.
pub fn convert(schema: &Value, options: &ConvertOptions) -> Result<ConvertResult, ConvertError> {
    let mut codec = Codec::new();

    // Pass 0: Normalize ($ref resolution, draft migration)
    let p0 = passes::p0_normalize::normalize(schema, options)?;
    let schema = p0.pass.schema;

    if !p0.recursive_refs.is_empty() {
        tracing::debug!(
            recursive_refs = ?p0.recursive_refs,
            "detected {} recursive $ref cycle(s) — will be broken in Pass 5",
            p0.recursive_refs.len()
        );
    }

    // Pass 1: Composition (allOf merge)
    let p1 = passes::p1_composition::compile_composition(schema, options)?;
    let schema = p1.merge_into_codec(&mut codec);

    // Pass 2: Polymorphism (oneOf → anyOf)
    let p2 = passes::p2_polymorphism::simplify_polymorphism(schema, options)?;
    let schema = p2.schema;

    // Pass 3: Dictionary (Map → Array)
    let p3 = passes::p3_dictionary::transpile_dictionaries(schema, options)?;
    let schema = p3.merge_into_codec(&mut codec);

    // Pass 4: Opaque (open objects → string)
    let p4 = passes::p4_opaque::stringify_opaque(schema, options)?;
    let schema = p4.merge_into_codec(&mut codec);

    // Pass 5: Recursion Breaking
    let p5 = passes::p5_recursion::break_recursion(schema, options)?;
    let mut schema = p5.merge_into_codec(&mut codec);

    // Pass 6: Strict enforcement
    if options.mode == Mode::Strict {
        let p6 = passes::p6_strict::enforce_strict(schema, options)?;
        schema = p6.merge_into_codec(&mut codec);
    }

    // Pass 7: Constraint pruning
    let p7 = passes::p7_constraints::prune_constraints(schema, options)?;
    let schema = p7.merge_into_codec(&mut codec);

    // Pass 9: Provider compatibility checks (soft errors)
    let p9 = passes::p9_provider_compat::check_provider_compat(schema, options);
    let provider_compat_errors = p9.errors;
    let schema = p9.pass.merge_into_codec(&mut codec);

    Ok(ConvertResult {
        schema,
        codec,
        provider_compat_errors,
    })
}

/// Rehydrate LLM output back to the original schema shape using the codec.
///
/// Type coercion is always applied using the provided `original_schema`
/// to fix LLM type mismatches (e.g. `"42"` where `integer` was expected).
///
/// # Arguments
///
/// * `data` - The JSON data generated by the LLM
/// * `codec` - The codec sidecar from conversion
/// * `original_schema` - The original JSON Schema (before conversion) used for type coercion
///
/// # Returns
///
/// A [`RehydrateResult`] containing the rehydrated data and any advisory warnings
/// about constraint violations or type coercions encountered during rehydration.
///
/// Warnings are *advisory only*: they never cause `rehydrate` to return `Err`
/// and are intended for logging, inspection, or telemetry rather than control flow.
///
/// # Examples
///
/// ```rust,no_run
/// use jsonschema_llm_core::{convert, rehydrate, ConvertOptions};
/// use serde_json::json;
///
/// let schema = json!({"type": "object", "properties": {"name": {"type": "string"}}});
/// let options = ConvertOptions::default();
/// let result = convert(&schema, &options).unwrap();
///
/// let llm_output = json!({"name": "Ada"});
/// let rehydrated = rehydrate(&llm_output, &result.codec, &schema).unwrap();
/// ```
///
/// # Warning Ordering
///
/// Warnings follow a deterministic phase-group order:
/// 1. Type coercion warnings (value type adjusted to match schema)
/// 2. Constraint enforcement warnings (value clamped/truncated to satisfy bounds)
/// 3. Constraint validation warnings (advisory: value violates a dropped constraint)
///
/// Enforcement may **auto-correct** values (e.g., clamping an integer that exceeds
/// `maximum`). Validation warnings are advisory-only and do not modify the data.
pub fn rehydrate(
    data: &Value,
    codec: &Codec,
    original_schema: &Value,
) -> Result<RehydrateResult, ConvertError> {
    // Phase 1: Apply transforms (reverse codec operations)
    let mut result = rehydrator::apply_transforms(data, codec)?;

    // Phase 2: Type coercion (e.g., string "42" → integer 42)
    let coercion_warnings = rehydrator::coerce_types(&mut result.data, original_schema);
    result.warnings.extend(coercion_warnings);

    // Phase 3: Constraint enforcement + validation (runs AFTER coercion so
    // constraints evaluate against correctly-typed values)
    let regex_cache = rehydrator::build_pattern_properties_cache(codec);
    let enforcement_warnings =
        rehydrator::enforce_constraints(&mut result.data, codec, &regex_cache);
    let validation_warnings = rehydrator::validate_constraints(&result.data, codec, &regex_cache);
    result.warnings.extend(enforcement_warnings);
    result.warnings.extend(validation_warnings);

    Ok(result)
}

// ---------------------------------------------------------------------------
// JSON-String Bridge API (FFI surface)
// ---------------------------------------------------------------------------

/// Format a `ConvertError` as a JSON string for FFI consumers.
fn err_json(e: ConvertError) -> String {
    e.to_json().to_string()
}

// ---------------------------------------------------------------------------
// Bridge Wrapper DTOs — inject apiVersion for FFI consumers
// ---------------------------------------------------------------------------

/// FFI envelope for conversion results. Injects `apiVersion` into the JSON output
/// while keeping `ConvertResult` clean for Rust consumers.
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct BridgeConvertResult<'a> {
    api_version: &'static str,
    #[serde(flatten)]
    inner: &'a ConvertResult,
}

/// FFI envelope for rehydration results. Injects `apiVersion` into the JSON output
/// while keeping `RehydrateResult` clean for Rust consumers.
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct BridgeRehydrateResult<'a> {
    api_version: &'static str,
    #[serde(flatten)]
    inner: &'a RehydrateResult,
}

/// Convert a JSON Schema (as a JSON string) with options (as a JSON string).
///
/// This is the FFI-friendly entry point — accepts and returns plain JSON strings.
/// The typed [`convert`] API remains available for Rust consumers.
///
/// # Arguments
///
/// * `schema_json` — A JSON Schema document as a string
/// * `options_json` — Conversion options as a JSON string. Fields use `kebab-case`
///   naming (e.g. `"max-depth"`, `"recursion-limit"`). Numeric options (`max_depth`,
///   `recursion_limit`) are deserialized as `usize`; values exceeding the platform's
///   pointer width will produce a deserialization error.
///
/// # Returns
///
/// * `Ok(String)` — `{"apiVersion": "1.0", "schema": {...}, "codec": {...}}`
/// * `Err(String)` — `{"code": "...", "message": "...", "path": ...}`
pub fn convert_json(schema_json: &str, options_json: &str) -> Result<String, String> {
    let schema: Value =
        serde_json::from_str(schema_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let options: ConvertOptions =
        serde_json::from_str(options_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let result = convert(&schema, &options).map_err(err_json)?;
    let bridge = BridgeConvertResult {
        api_version: API_VERSION,
        inner: &result,
    };
    serde_json::to_string(&bridge).map_err(|e| err_json(ConvertError::JsonError(e)))
}

/// Rehydrate LLM output (as a JSON string) using a codec and original schema.
///
/// This is the FFI-friendly entry point — accepts and returns plain JSON strings.
/// The typed [`rehydrate`] API remains available for Rust consumers.
///
/// # Arguments
///
/// * `data_json` — The LLM-generated JSON data as a string
/// * `codec_json` — The codec sidecar (from a prior conversion) as a JSON string
/// * `original_schema_json` — The original JSON Schema as a string (for type coercion)
///
/// # Returns
///
/// * `Ok(String)` — `{"apiVersion": "1.0", "data": {...}, "warnings": [...]}`
/// * `Err(String)` — `{"code": "...", "message": "...", "path": ...}`
pub fn rehydrate_json(
    data_json: &str,
    codec_json: &str,
    original_schema_json: &str,
) -> Result<String, String> {
    let data: Value =
        serde_json::from_str(data_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let codec: Codec =
        serde_json::from_str(codec_json).map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let original_schema: Value = serde_json::from_str(original_schema_json)
        .map_err(|e| err_json(ConvertError::JsonError(e)))?;
    let result = rehydrate(&data, &codec, &original_schema).map_err(err_json)?;
    let bridge = BridgeRehydrateResult {
        api_version: API_VERSION,
        inner: &result,
    };
    serde_json::to_string(&bridge).map_err(|e| err_json(ConvertError::JsonError(e)))
}
